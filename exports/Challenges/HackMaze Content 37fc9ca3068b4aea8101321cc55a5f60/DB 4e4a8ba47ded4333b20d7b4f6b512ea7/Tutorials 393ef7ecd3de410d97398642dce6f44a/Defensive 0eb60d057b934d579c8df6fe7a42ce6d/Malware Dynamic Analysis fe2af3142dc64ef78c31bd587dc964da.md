# Malware Dynamic Analysis

# Dynamic Analysis

> **Dynamic Malware Analysis** is analyzing malware samples by running them in a contained environment. We will observe the systems and services, which are being affected during the execution, whether the malware is hiding, and if so, how is it hiding itself. All of this a contained environment.
> 

> **contained environment** can be anything from a simple virtual machine, all the way to a physically separated system, running on a physically separated network.
> 

<aside>
üëæ ***Execution Environments:***

1. Virtual Machines
2. Separate Physical Systems
3. Automated Sandbox
</aside>

<aside>
üëæ ***Tools to Help:***
When running the sample on a physical system, it is great to have tools that can provision the system back to a normal clean state again; in other words, ‚Äúreboot to restore‚Äù. You don‚Äôt want to have to set up your workstation from scratch, do you?

<aside>
üõ†Ô∏è ***Shadow Defender (SD)*:** An easy-to-use reboot-to-restore security solution for Windows that protects your computer‚Äôs real environment against malicious activities and unwanted changes. SD can run your system in a virtual environment called '**Shadow Mode**‚Äô, which can redirect each system change to a virtual environment with no change to your real environment. This makes it convenient for malware analysis.

</aside>

<aside>
üõ†Ô∏è ***DeepFreeze***: Another good reboot-to-restore security solution, which allows system administrators to protect the core operating system and configuration files on a workstation or server by restoring a computer back to the saved configuration, each time the computer is restarted.

</aside>

</aside>

> **Sandboxie**: Runs your programs in an isolated space, which prevents them from making permanent changes to other programs and data in your computer.
> 

<aside>
üõ†Ô∏è ***RollBack Rx Professional:***

RollBack Rx Professional is an instant time machine for your PC. A comprehensive Windows System Restore solution that empowers users and IT administrators to easily restore their PCs to any previous state within seconds, which again makes it good for our case.

</aside>

> ***Feeding the Malware:*** provide the sample you‚Äôre working on with all the environmental requirements it needs.
> 

**There are two states to define the security level of the contained environment you create:**

1. Insecure environment
2. Hardened environment

> **Insecure environment**: create an environment that lacks many of the security measures on purpose, to see how the malware acts. This also means running the sample with high privileges to see its capabilities when running as a high integrity process.
> 

> **Hardened environment:** used to test the ability to withstand a successful compromise in the environment. In other words, you want to test how well secure is the environment if that malware sample was executed in it.
> 

![Untitled](Malware%20Dynamic%20Analysis%20fe2af3142dc64ef78c31bd587dc964da/Untitled.png)

<aside>
üëæ ***Dynamic Analysis Methodology:***

- **Phase 1: Baseline**
    1. Create a VM with the OS needed.
    2. Install all the tools needed.
    3. Take a snapshot of the VM.
- **Phase 2: Pre-Execution**
    1. Perform any specific configuration if needed.
    2. Transfer Malware Sample to VM.
    3. Start the required tools (e.g. monitoring, tracking, debugging, etc.).
- **Phase 3: Post-Execution**
    1. Execute the Malware.
    2. Start tracking and monitoring its behavior and activity. System calls, File access, Network traffic, Etc‚Ä¶
    3. Dump/Capture screenshots, memory dumps, config files, registry files, unpacked executables, etc.
- **Phase 4: Analyze and Document**
    1. Analyze and take notes of everything that happened.
    2. Observe exhibited behavior.
    3. Document events and actions.
</aside>

# Windows Processes

<aside>
üëæ ***Process Elements:***

1. **Executable Image:** executable program itself, the file that includes the code to be executed Every process will have at least one image file
2. **Private Virtual Address Space:** used to load the resources required This could be the image file, the libraries required, stack, heap, and other resources.
3. **Private Handle Table:**  we have a process that wants to write to a file, what will happen is the process requests access to the file through the kernel. The kernel will be responsible for opening the file and creating a handle, which is later added to the handle table, so now the process can use it to access the file
    
    <aside>
    üõ†Ô∏è ***SysInternals WinObj***: to know what objects exists on a Windows system
    
    </aside>
    
4. **Access Token:** stores the default security context of the process, which later is used by the thread that will be doing the actual execution of the code
5. **Thread(s):** rue execution units of a process. They are the ones doing the execution.
</aside>

<aside>
‚ö†Ô∏è ***NOTE***:

Another important thing to keep in mind is a process should normally start from the entry point as we mentioned previously, but that might not always be the case and some malware might start executing from the **thread local storage (TLS)**!!

</aside>

## Private Virtual Address Space (VAS)

### VAS Size

This address space is private to the process itself and is what helps create the contained and isolated environment for the process to run in it safely, without interfering with other processes running on the machine.

<aside>
üëæ ***The size of the user space VAS for each process depends on three main features:***

1. Is the process 32-bit or 64-bit?
2. Is the system 32-bit or 64-bit?
3. Is the linker flag /LARGEADDRESSAWARE: yes set?
</aside>

<aside>
‚ö†Ô∏è ***NOTE:***

Each process on a 32-bit system have **2GB** by default.

If 32-bit process on 32-bit system has been linked with the LARGEADDRESSAWARE flag, it could be increased to a max of **3GB**. Done using: **`BCDEdit /set increaseuserva Megabytes`**

If 32-bit process on 64-bit system and has been linked with the LARGEADDRESSAWARE flag, then it has 4GB. If not, then it will have the default 2GB.

For 64-bit processes on a Windows 8 and earlier, it will have 8TB VAS and 128TB for Windows 8.1 and later.

</aside>

### Processor Modes

**Processes can be running in one of two modes:**

- User-mode
- Kernel-mode

The processor switches between the two modes available depending on the type of code being executed. What this means is there is a VAS reserved for code running in:

> User-mode code called ‚Äú**User space**‚Äù.
> 
> 
> Kernel-mode code called ‚Äú**Kernel space**‚Äù.
> 

<aside>
üëæ ***Addressing ranges:***

**32-bit User & Kernel VAS:** 

**lower address** ranges from 0x00000000 to 0x7FFFFFFF is used for the user space.
**Higher address** ranges from 0x80000000 to 0xFFFFFFFF is used for the kernel space.

**64-bit User & Kernel VAS:**

The address ranges from 0x000'00000000 through 0x7FF'FFFFFFFF is used for the user space.
The address ranges from 0xFFFF0800'00000000 through 0xFFFFFFFF'FFFFFFFF is used for the kernel space.

</aside>

> **Virtual Memory: ****Processes always deal with **virtual memory** and the reason why it is referred to as virtual, is because:
> 
> - There is an indirect relationship between the address used and the address in physical memory.
> - An allocated buffer for a process could be mapped to a physical address or could be mapped to a file on-disk called page.

<aside>
‚ö†Ô∏è ***NOTE:***

The process does not need to know if the memory address that is going to be accessed is actually in physical memory or not. If the memory address that is going to be executed is in physical memory (RAM), then the CPU will execute it, if not then what happens is the CPU will raise a page fault
and that will inform the memory manager to go fetch that page where the data resides in and load it into the memory for the CPU to execute it.

</aside>

**VAS vs Physical Address Space (PAS):**

Now, each process will be divided into what is called pages (4 kilobytes in size) and again, not all pages are loaded into the main memory (RAM), only those needed. 

**Mapping VAS to PAS:**

When the process needs to access a location, the table is checked to see if that address is in physical memory or not. If it is, then it will be accessed, if not, then it will trigger a page fault as we said and then get loaded into physical memory, which leads to updating this table.

**Shared Libraries (DLLs):**

Virtual memory also helps in utilizing the physical memory, by only loading the required data into physical memory to be executed. If it is not going to be executed, then no need to load it

<aside>
‚ö†Ô∏è ***NOTE:***

- If the DLL is designed to be shared among processes and is configured as a shared DLL, it may be loaded into memory only once and shared by multiple processes.
- If the processes are configured to load the DLL in an isolated manner or if they use different versions or configurations of the DLL, each process may have its own instance of the DLL in memory.
</aside>

## Process Creation Steps

<aside>
üëæ ***Process Creation Steps Continued:***

1. The first thing that happens is the kernel opening the image file and verifying if it is truly a portable executable (PE) file and following its file format specifications.
2. After that, the kernel creates an object for the process and another object for the thread.
3. Then the kernel will map the image file to the process and the NtDLL.DLL file is mapped to the process as well.
4. Now a notification will be sent to the Windows subsystem process (Csrss.exe) with details that a new process and thread have been created. 
5. By now, the kernel has created and prepared the environment for the process and could move on to the execution phase.
6. Now some initializations take place such as creating the heap pool for both the process and the thread.
7. The last part is to load the required DLLs, such as Kernel32.DLL, User32.DLL, Advapi32.DLL, etc.

<aside>
‚ö†Ô∏è ***NOTE:***

- The CreateProcess API call is in a simple C++ code within a main() function. Many would think that the first execution step is going to be the main() function, but that is not true and there are other operations that happen before the main function and the code inside it gets executed.
- In reality, the NtDLL still needs to do some other tasks, which are creating the Process Environment Block (PEB) and the Thread Environment Block (TEB). These are covered in detail in the memory forensics module.
- process could be created using other functions such as **`CreateProcess`, `CreateProcessAsUser` , `CreateProcessWithToken` , `WinExec ShellExecute` ,`NtCreateProcess` , `NtCreateThread` , `NtCreateUserProcess`, `CreateProcessInternal`**
    
    ![Untitled](Malware%20Dynamic%20Analysis%20fe2af3142dc64ef78c31bd587dc964da/Untitled%201.png)
    
</aside>

</aside>

# Sysinternals Tools

<aside>
üõ†Ô∏è ***SysInternals***

- listDLLs: List all dlls in a process **`ListDll.exe notepad`**
- WinObj: display Kernal objects (GUI)
- handles: list handles in kernal **`handles.exe`**
- Process Monitor (Procmon):  advanced process monitoring tool that could show you in real-time what a process/thread activity looks like behind the scenes.
    1. **Boot Logging** Procmon can be configured to start logging system activity at a very early point in the booting process. **`Options menu ‚Üí select the Enable Boot Logging`**
    2. **Drop Filtered Events** This option in the Filter menu will reduce the number of captured logs by Procmon. Use this option only if you‚Äôre sure about what exactly you need.
    3. **History Depth** Procmon keeps track of memory usage and will stop events capturing if the - system‚Äôs **`Options ‚Üí History Depth`**
    4. Backing Files To keep Procmon logging events in case the virtual memory runs low, we can configure it to store captured events to a particular file on the disk by choosing **`‚ÄúBacking Files‚Äù from the File menu.`**
</aside>

# System Processes & Services

| ProcName | job | Parent | PID | Image | cmdline |
| --- | --- | --- | --- | --- | --- |
| System Idle  | - This is not truly a process and is used to track the idleness of the system‚Äôs CPU but Created by  ntoskrnl.exe. placeholder indicating that your CPU is currently available.
- Run in kernel mode always
- Number of threads represents the number of available CPUs
- One thread for each CPU to keep it busy                                                                                                                        -It ensures the CPU is always busy with some task, even if that task is simply waiting for instructions.
-Without the System Idle process, the CPU wouldn't know what to do in those idle moments. | Null  | 0 | Null  | Null  |
| Registry | - Used to manage the Windows registry instead of using page pools. So it‚Äôs used as a cache for the Windows Registry in memory instead of on disk. | Null  | depends | Null | Null |
| System  | - Created by ntoskrnl.exe
- Runs in kernel mode only
- Owns the sockets and handles to any file that the kernel opens
- Processes ID are multiple of 4 with the value 4 belonging to system | No parent but 3 children:                                ‚Ä¢ Interrupts
‚Ä¢ smss.exe
‚Ä¢ Memory Compression | 4 | Null | Null |
| interrupts | - Just used to measure the time required to service HW interrupts and deferred Procedure Calls | System | depends | Null | Null |
| Memory Compression | - Used to hold compressed memory in its address space
- Useful for systems with limited resources | System | depends |  |  |
| Windows
Session
Manager
Subsystem
(smss.exe) | - 1st User-mode process
- Responsible of starting user session
- Only one copy should exist at any given time!
- Create user session #1
- Create user session #0 (system services)
- Starts during the boot sequence
- Initializes environment variables
- Loads subsystems: OS/2, POSIX, Windows (Win32) subsystem.
- Loads both kernel & user-modes of Win32 subsystem: Win32k.sys (kernel-mode), and winsrv.dll & csrss.exe (user-mode)
- Creates DOS device mappings (e.g. COM, LPT1, and drive letters) listed at HKLM\\System\\CurrentControlSet\\Control\\Session Manager\\DOS Devices
- Creates virtual memory paging files | Parents:  System or smss.exe for the children | depends  | C:\Windows\System32\smss.exe | C:\Windows\System32\smss.exe |
| Windows Initialization Process (wininit.exe) | - Creates the %windir%\temp directory
- DEP and High Entropy ASLR enabled
- Check Strings /Environment | Parent: another smss.exe creates this process then exits.               children :     ‚Ä¢services.exe
‚Ä¢ lsass.exe
‚Ä¢ Fontdrvhost.exe
‚Ä¢ Ism.exe
‚Ä¢ LsaIso.exe
‚Ä¢ WerFault.exe | depends | C:\Windows\System32\wininit.exe | wininit.exe |
| Windows
Service Control
Manager (SCM)
Services.exe | -ASLR, DEP, CFG all enables
- Used to control services that run as background services and are not attached to a user session
- SCM will either directly start the process or call svchost.exe which will host the service DLLS.
- Only one instance should be running at any given time
- Runs under session 0 | parent: wininit.exe Children:
‚Ä¢ svchost.exe
‚Ä¢ Third Party Services
‚Ä¢ Standalone .exe
‚Ä¢ System Scheduled Tasks | depends  | %SysteRoot%\System32\services.exe | wininit.exe |
| Windows
Service Host
Process
(svchost.exe) | - Multiple instances can be running
-  User should be one of three options:
     o NTAUTHORITY\SYSTEM
     o LOCAL SERVICE
     o NETWORK SERVICE
- Must include -k <name>, where <name> is a category key value in the registry: Software\Microsoft\Windows NT\currentVersion\Svhost
- All instances should be running in session 0 | Parent: services.exe            Children: many  |  | C:\Windows\System32\svchost.exe |  |
| Local Security
Authentication
Server
(lsass.exe) | - Auto Start location: HKLM\System\CurrentControlSet\Services\VaoHSV
- Runs in session 0 (3e7)                                                                                                                                                                            - enforcing the security policy, verifying passwords (Receives the username and password that captured by winlogon.exe for authentication ) and creating access tokens by calling    NtCreateToken .                                                                                                                                                                            -  Target for code injection | Parent: wininit.exe                         Children: Rare |  | C:\Windows\system32\lsass.exe |  |
| explorer.exe | - Autostarts from: HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Shell | userinit.exe, Winlogon.exe but can be anything.exe using explorer.exe |  |  |  |
| Windows
Logon
(winlogon.exe) | - Used for interactive user logon\logoff when SAS keystroke combinations are used (ctrl+alt) --
Processes Ctrl+Alt+Del
- Runs in session 1
- Monitors files and directories changes that implement Windows File Protection
- Might create LogonUI.exe when credentials are required, and UI displays the logon dialog.
- Network Provider DLLs can also be called by winlogon.exe if additional secure authentication is required
- Is used to send the username & password to LSASS.EXE through LPC and receives access
token object that contains the user's security profile. | Parent: smss.exe  or No           children:                                                  ‚Ä¢ dwm.exe
‚Ä¢ mpnotify.exe
‚Ä¢ fontdrvhost.exe
‚Ä¢ userinit.exe
‚Ä¢ scrnsave.exe
‚Ä¢ PhotoScreensaver.scr |  | C:\Windows\System32\winlogon.exe | C:\Windows\System32\winlogon.exe |
| Windows
Client/Server
Runtime
Subsystem
(Csrss.exe) | - User-mode process, part of the windows32 subsystemnLegacy 
- Responsible for console Windows
- Creates/deletes processes and threads, temp files, etc
- With win32.sys kernel-mode devices driver, plus conhost.exe for console windows, plus a range of DLLs to convert Windows API calls to kernel mode system service calls.
- An idle process that contains a single thread to monitor the CPU's idle time |  Null |  | C:\Windows\System32\csrss.exe |  |
| Windows User Initialization (userinit.exe) | Initializes the user environment and launches Explorer.exe, then exits. Note that Winlogon.exe, the parent of userinit.exe, doesn't exit as it handles system logoff also. | Parent: winlogon.exe             Children: explorer.exe |  |  |  |
| conhost.exe | acts as the host for console applications, providing the necessary environment for them to run. | Parent: Many                                  Children: Rare  |  |  |  |

![Untitled](Malware%20Dynamic%20Analysis%20fe2af3142dc64ef78c31bd587dc964da/Untitled%202.png)

<aside>
‚ö†Ô∏è ***NOTE:***

- Process IDs on Microsoft Windows are multiple of 4, with the value of 4 always belonging to System.
- there will be one (csrss.exe) for the system and then one for each user that is logged into the machine. If there are two users logged into a machine, there would be three csrss.exe processes. It would be suspicious if any one user had multiple instances running. Csrss.exe is used for "Console Windows, creating and/or deleting threads, and some parts of the 16-bit virtual MS-DOS environment.
</aside>

## Windows On Windows 64 (WoW64)

> **WoW64** is a subsystem of the Windows operating system capable of running 32-bit applications on 64-bit Windows. WoW64 is an interface between the 32-bit version of Ntdll.dll and the kernel of the processor, and it intercepts kernel calls.
> 

<aside>
üëæ ***WOW64 emulator DLLs consists of:***

1. **Wow64.dll**: the core emulation infrastructure and the thunks for the Ntoskrnl.exe entry-point functions.
2. **Wow64Win**.**dll**: provides thunks for the Win32k.sys entry-point functions.
3. **Wow64Cpu.dll** (x64 only): provides support for running x86 programs on x64.

***On a Windows 64-bit System, there will be two sets of Executables and DLLs:***

1. C:\Windows\System32 ‚Üí Native 64-bit
2. C:\Windows\SysWoW64 ‚Üí 32-bit images
</aside>

Q:  **Why all this redundancy in DLLs and EXEs?**

A:  because 32-bit processes cannot load 64-bit DLLs and the opposite is true too! Also if you recall from previous modules, the pointer sizes and address ranges are both different, which means they just cannot work without this emulation! The only exception is DLLs that contain resources only.

<aside>
üëæ ***WoW64 Registry Redirector:***

- Similar to the file system redirector, the registry also has a redirector to isolate 32-bit and 64-bit applications by providing separate logical views of certain portions of
the registry.
- Registry calls are intercepted to their respective logical registry views and are mapped to their corresponding physical registry location.
- The redirection process is transparent to the application.
</aside>

> **Ntdll.dll**: is a special-purpose DLL that contains internal support functions and system-service dispatch stubs to executive functions. Ntdll.dll maps the incoming API requests to their corresponding kernel services through a mechanism called system service dispatching.
> 

> **Kernel32.dll**: is commonly mistaken as the Windows kernel but is actually a user-mode DLL that simply passes on requests for the kernel to ntdll.dll. Kernel32.dll, Advapi32.dll, User32.dll, Gdi32.dll: are core Windows subsystem DLLs
> 
- Ntoskrnl.exe: Executive and kernel
- Hal.dll: HAL
- Win32k.sys: kernel-mode part of the windows subsystem (GUI)
- Hvix64.exe: Intel Hypervisor
- Hvax64.exe: AMD Hypervisor
- .sys files in \systeRoot\System32\Drivers core driver files, such as DirectX, VolumeManager, TCP\IP, TPM, and ACPI support

> **service** is just a process, the only difference being that it is usually running in the background and the user might not directly interact with it! In other words, it‚Äôs a background process.
> 

# Injection Techniques

> **Process injection** is used by malware as an evasion technique. It involves executing custom code within another process address space to improve stealth and in some cases to achieve persistence.
> 

## 1. Classical DLL Injection:

> **Classical DLL Injection** the malware writes the path to its DLL into the address space of legitimate process and creates a remote thread in the targeted process to guarantee that the remote process will load the injected code.
> 

<aside>
üëæ ***Steps:***

1. the malware selects a target process to inject its code in, e.g. svchost.exe. Usually, the malware searches for a target process using three APIs:
    - **`CreateToolhelp32Snapshot`**: This API is used to retrieve a snapshot for the heap or module state of a particular process or for all processes.
    - **`Process32First`**: Return information about the first process from the snapshot from previous process
    - **`Process32Next`**: Used to iterate through processes retrieved by CreateToolhelp32Snapshot.
2. After determining a target process, the malware calls **`OpenProcess`**to get a handle of the target process. Now the malware has a handle to use and access the target process. ŸÑŸÖÿß ÿ®ÿ±Ÿàÿ≥Ÿäÿ≥ ÿ®ÿ™ÿßÿÆÿØ ŸáÿßŸÜÿØŸÑ ÿ¨Ÿàÿß ÿ®ÿ±Ÿàÿ≥Ÿäÿ≥ ÿØŸá ŸÖÿπŸÜÿßŸá ÿßŸÜ ÿßŸÑŸÑŸä ŸàÿßÿÆÿØŸá ÿØŸä ŸÑŸäŸáÿß ÿßÿ≠ŸÇŸäÿ© ÿßŸÜŸáÿß ÿ™ÿßŸÉÿ≥ÿ≥ ÿßŸÑÿ®ÿ±Ÿàÿ≥Ÿäÿ≥ ÿßŸÑÿ™ÿßŸÜŸäÿ© Ÿà ÿ™ÿπŸÖŸÑ ÿ¨ŸàÿßŸáÿß ÿßŸàÿ®ÿ±Ÿäÿ¥ŸÜ ŸÖÿπŸäŸÜÿ© ÿπÿ¥ÿßŸÜ ŸÉÿØŸá ÿßŸÑŸÖÿßŸÑŸàŸäÿ± ÿ®Ÿäÿ≠ÿßŸàŸÑ ŸäÿßŸÉÿ≥ÿ≥Ÿáÿß 
3. To allocate memory space to write the path to its DLL, the malware calls **`VirtualAllocEx`**    ÿØŸá ÿπÿ¥ÿßŸÜ ŸäÿßŸÉÿ≥ÿ≥ ÿßŸÑŸÖŸäŸÖŸàÿ±Ÿä
4. it calls **`WriteProcessMemory`** to write the path in the memory of targeted process. ÿØŸá ÿπÿ¥ÿßŸÜ ŸäŸÉÿ™ÿ® ŸÅŸâ ÿßŸÑŸÖŸäŸÖŸàÿ±Ÿä ÿ≥ÿ®Ÿäÿ≥ ÿßŸÑÿ®ÿßÿ´ ÿ®ÿ™ÿßÿπŸá
5. Then the malware will call an API function, such as **`CreateRemoteThread`**, **`RtlCreateUserThread`**, or **`NtCreateThreadEx`**, to execute the injected code. This is done by passing the **`LoadLibrary`** address to any of these APIs to ensure that the injected DLL will be executed by a remote process on behalf of the malware.
</aside>

## 2. PE Injection:

> **PE Injection** the malware copies its malicious code (instead of passing the address to **`LoadLibrary`**) into an existing process and runs it using shellcode or by calling **`CreateRemoteThread`**. The advantage of this technique over the previous technique is that it does not require a malicious DLL on the disk ÿ®Ÿäÿµÿπÿ® ÿßŸÉÿ™ÿ± ÿßŸÜ ÿßŸÑÿßŸÜÿ™Ÿä ŸÅÿßŸäÿ±ÿ≥ Ÿäÿπÿ±ŸÅ Ÿà ÿ®ŸäŸÉŸàŸÜ  ŸÖÿ™ÿÆŸÅŸâ ÿßŸÉÿ™ÿ± ŸÑÿßŸÜ ŸÉŸÑ ÿ≠ÿßÿ¨ÿ© ÿ®ÿ™ÿ™ŸÖ ŸÅŸâ ÿßŸÑŸÖŸäŸÖŸàÿ±Ÿä ŸÖÿ¥ ÿßŸÑÿØŸäÿ≥ŸÉ
> 

<aside>
üëæ ***Steps***:

1. first allocates memory space in a target process, e.g. **`VirtualAllocEx`**.
2. malware then writes its code, instead of the DLL path, in the allocated memory space by calling **`WriteProcessMemory`** function.

ŸÜÿ™Ÿäÿ¨ÿ© ÿßŸÜ ÿßŸÑŸÖÿßŸÑŸàŸäÿ± ŸáŸäÿ≠ÿ∑ ÿßŸÑŸÉŸàÿØ ÿ®ÿ™ÿßÿπŸá ŸÅŸâ ÿ®ÿ±ÿ≥Ÿäÿ≥ ÿ™ÿßŸÜŸäÿ© ŸÖÿπŸÜÿßŸáÿß ÿßŸÜŸá ŸáŸäÿ∫Ÿäÿ± ÿßŸÑÿ®Ÿäÿ≤ ÿßÿØÿ±Ÿäÿ≥ ÿßŸÑŸÑŸä ŸáŸà ÿπÿ®ÿßÿ±ÿ© ÿπŸÜ ÿßŸÑŸÖŸÉÿßŸÜ ÿßŸÑŸÑŸä ŸáŸäÿ™ÿ≠ÿ∑ ŸÅŸäŸá ÿßŸÑÿ®ÿ±Ÿàÿ≥Ÿäÿ≥ ŸÅŸâ ÿßŸÑŸÅŸäÿ±ÿ¥ŸàÿßŸÑ ŸÖŸäŸÖŸàÿ±Ÿä ŸÅŸÑÿßÿ≤ŸÖ ÿßŸÑŸÖÿßŸÑŸàŸäÿ± ŸäŸÑÿßŸÇŸä ÿ∑ÿ±ŸäŸÇÿ© ÿπÿ¥ÿßŸÜ Ÿäÿπÿ±ŸÅ ÿßŸÑÿ®Ÿäÿ≤ ÿßŸÑÿ¨ÿØŸäÿØ Ÿà Ÿäÿ≠ÿ∑ ŸÜŸÅÿ≥Ÿá ŸÅŸäŸá

This technique is less stealthy than other techniques, such as memory module and Reflective DLL injection, since it relies on extra Windows APIs, e.g., **`LoadLibrary`** or **`CreateRemoteThread`**.

When analyzing PE injection, you may see nested loops (two for loops), before a call to the **`CreateRemoteThread`** function. This technique is used by Crypters (software that
obfuscate malware traces using encryption).

</aside>

> **Reflective DLL** injection creates a DLL that can map itself into memory for execution instead of relying on the Windows loader.
> 

> **Memory Module** technique, the loader or injector is responsible for mapping the malicious DLL to memory instead of the DLL mapping itself.
> 

## 3. Process Hollowing (Process Replacement / RunPE):

> un-maps or hollows out the code of a legitimate process from memory and overwrites the memory space of the victim process by its malicious code.
> 

<aside>
üëæ ***Steps:***

1. The malware starts by creating a new process in a suspended state. by using **`CreateProcess`** and sets the flag of process creation into CREATE_SUSPENDED (0x00000004) and will remain suspended until the malware calls the **`ResumeThread`** function.
2. the malware replaces the legitimate file contents by its malicious payload. This memory unmapping is done using **`NtUnmapViewOfSection`** or **`ZwUnmapViewOfSection`** APIs, which release all memory contents pointed to by a section.
3. the loader calls **`VirtualAllocEx`** to allocate new memory space for the malware. The loader uses **`WriteProcessMemory`** function to write the malware‚Äôs sections into the target process memory space.
4. The malware uses **`SetThreadContext`** function to determine the Entry point of the new code section, which has been written. 
5. Finally, the suspended thread is resumed by the malware using **`ResumeThread`** function.
</aside>

## 4. Thread Execution Hijacking:

> also known as Suspend, Inject and Resume or SIR. Instead of injecting the shell code using the DLL name, this injection variant inject malicious code into the existing thread of a process
> 

<aside>
üëæ ***Steps***

1. First, the malware gets a handle to the victim‚Äôs thread.
2. it puts the thread into suspended state using **`SuspendThread`** function to perform its injection.
3. malware then calls **`VirtualAllocEx`** function to allocate memory space. Then calls **`WriteProcessMemory`** function for code injection.
4. The injected code may contain shellcode, a path to malicious DLL, or the address of **`LoadLibrary`** function

The SIR approach may arise a problem for adversaries, since suspending a process and resuming it during a system call may crash the system. Sophisticated malware could probably avoid this problem by resuming and trying later, especially if the instruction pointer is pointing to an address within the range of the NTDLL.dll library.

</aside>

## 5. Injection via Hooks (SetWindowsHookEx):

> **Hooking** techniques are used to intercept function calls. Malware can use it to load their malicious DLL upon an action getting triggered in a particular thread.
> 

<aside>
üëæ ***Steps:***

1. In order to install a hook function into the hook chain, malware may call **`SetWindowsHookEx`**. The **`SetWindowsHookEx`** function requires four arguments:
    1. The first is the event type, which indicates the range of hook type and varies from mouse inputs (WH_MOUSE) to keyboard pressing keys (WH_KEYBOARD), CBT, etc.
    2. The second one is a pointer to the function the malware wants to invoke upon the event execution.
    3. The third one corresponds to the module, which contains the function that the malware will invoke. Therefore, **`LoadLibrary`** and **`GetProcAddress`** are called before **`SetWindowsHookEx`**.
    4. The fourth argument is the thread that will be associated with the hook procedure. If it is set to zero, all threads will perform the action upon the event triggering. Commonly, malware targets only one thread for minimal noise.
2. After the DLL injection, the malware will execute its malicious code on behalf of the process, whose thread-Id was sent to **`SetWindowsHookEx`** function.
</aside>

## 6. Injection via Registry Modifications:

> The registry keys: AppCertDlls, Appinit_DLL, and IFEO (Image File Execution Options) are used by malware for both code injection and to maintain persistence.
> 

<aside>
üëæ ***Steps:***

1. **Appinit_Dlls:** Malware can use the Appinit_Dlls registry key to store the location of their malicious library, thus, another process will load their library. All libraries stored under this key will be loaded into every process that loads the **User32.dll** which is  library is very common and used to store graphical elements, e.g, dialog boxes. Therefore, by modifying this subkey, the malware guarantees that most of the processes will load their malicious library.
2. **AppCertDlls**:  DLLs under this subkey will be loaded into every process that calls the **Win32 API** functions: **`CreateProcess`**, **`CreateProcessWithLogonW`**, **`WinExec`**, **`CreateProcessAsUser`**, **`CreateProcessWithTokenW`**
3. **Image File Execution Options (IFEO):** utilized for debugging purposes. For example, the ‚ÄúDebugger Value‚Äù under this subkey is used by developers to attach a program to another executable for debugging.

***Location***:

**`HKLM\Software\Microsoft\Windows NT\CurrentVersion\Windows\Appinit_Dlls
HKLM\Software\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows\Appinit_Dlls
HKLM\System\CurrentControlSet\Control\Session Manager\AppCertDlls
HKLM\Software\Microsoft\Windows NT\currentversion\image file execution options`**

</aside>

## 7. APC Injection and AtomBombing:

> Malware exploits **Asynchronous Procedure Calls (APC)** to impose legitimate threads to execute their malicious code. This can be done by attaching their code to the APC Queue of the target thread. Every thread is associated with a queue of APCs that wait for execution when the thread enters in alterable state.
> 

<aside>
üëæ ***Steps:***

- Malware selects a thread that is in an alterable state (can be changed, modified, or adjusted).
- Calls **`OpenThread`** and **`QueueUserAPC`** functions to queue an APC to a thread. **`QueueUserAPC`** requires three arguments:
‚Ä¢ A handle to the selected thread
‚Ä¢ A pointer that points to the function, which the malware wants to execute
‚Ä¢ Finally, the parameter, which will be passed to the function pointer.
</aside>

## 8. Extra Window Memory Injection (EWMI):

> Upon the registration of a window class, the application can determine an additional number of memory bytes, called **extra window memory (EWM)**. Since the EWM space is limited, the malware writes its code in a shared section of explorer.exe, and then uses **`SetWindowLong`**and **`SendNotifyMessage`** to make a function pointer to the shellcode, and finally executes it.
> 

<aside>
üëæ ***Steps:***

1. To write into the shared section, the malware may use one of two possibilities:
    1. Create a shared section and have it mapped both to itself and to another process
    2. Open an already existing shared section (most used)
2. After writing the code into the shared section, the malware uses **`GetWindowLong`**and **`SetWindowLong`**to enter and change additional window memory of ‚ÄúShell_TrayWnd‚Äù. they are used to retrieve and change the 32-bit value at the determined offset into the extra window memory of a window class object.
3. To trigger the code execution, the malware calls the **`SendNotifyMessage`**then, Shell_TrayWnd will receive and transfer the control to the address indicated by the value which was set by **`SetWindowLong`**.
</aside>

## 9. Early Bird API Injection:

> it is a powerful injection technique that enables adversaries to inject malicious code into target processes before their main thread starts. Hence, it can evade detection by most anti-malware products, which use Windows hook engines.
> 

<aside>
üëæ ***Steps:***

1. Create a legitimate process, e.g., svchost.exe, in suspended state.
2. Allocate memory in the created process.
3. Write the shellcode into the allocated memory space.
4. Queue an asynchronous procedure call (APC) to the main thread of the created process.
5. Call **`NtTestAlert`**function to instruct the kernel to execute malicious code when the main thread resumes running because the APC can start process running only when it is in an alertable state.
</aside>

## 10. API Hooking Techniques:

> Adversaries use the API hooking technique (which is based on process injection) to intercept calls to Windows APIs in order to modify the input or output of these commands.
> 

<aside>
üëæ ***Using API hooking, the malware can have:***

1. Full control over a particular process and record user experience resulted from the interaction with that process, e.g. browsers, visited web sites, antiviruses programs and files scanned by these antiviruses.
2. The ability to capture sensitive data stored in the process memory or API arguments.
3. inspect, modify, and filter any data sent by or returned to a function that is running within a program.
4. API Hooking can be used for different legitimate reasons
5. Hiding the existence of a malware (rootkits)
6. Stealing banking details
7. Inject into child process or prevent processes from starting
</aside>

### API hooking Techniques

> **Inline hooking** changes the flow of a process through Hotpatching, which refers to the modification of code during the running time of an executable image. the malware may change the first few bytes (generally, first five bytes) in the assembly code of an API and
> 

> **Inline API Hooking with Trampoline**: using a Trampoline, the malware is able to modify the API return value and any associated data with it. This gives the malware more control of the API & its output.
> 

### IAT Hooking

> **Import Address Table (IAT)** is a lookup table used to keep the addresses of all functions needed by a program in memory.IAT hooking, is not a widely used technique, however, it does not need trampoline disassembler or code patching. It modifies the import table addresses to point to the hooking_function instead of the actual API. The hooking_function then run jmp on the actual address of the API or push the arguments of the API to the stack and executes call and then return to the actual program.
> 

### Detecting API Hooking:

<aside>
üëæ ***How to detect:***

- Since API hooking is based on process injection, detecting API hooking in memory is similar to detecting process injection.
- Besides **`malfind`** and **`hollowfind`**, volatility commands, such as **`apihooks`**, can be used. Apihooks scan the process‚Äôs libraries to search for hooked API (in this case, APIs that start with jmp or a call). Apihooks lists the hooked APIs names and hooking_functions addresses.
</aside>

# Persistent Methods

## Windows Registry

<aside>
üëæ ***Windows Registry Locations for Autoruns:***

**`NTUSER.DAT\Software\Microsoft\ Windows\CurrentVersion\Run
HKCU\Software\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows
HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce\*
HKLM\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Run\*
HKLM\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\RunOnce\*
HKLM\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run\*`**

</aside>

<aside>
üõ†Ô∏è ***Autoruns*** to list most of the locations that are being used to automatically execute.

</aside>

## Task Scheduling

Malware authors might also use the task scheduler to schedule their malware to start at a certain time, after a certain event, or while the system is starting (boot-time).

**`schtasks /create /tn svchost /tr C:\Users\<victimuser>\AppData\Local\<Name>\svchost.exe /sc ONSTART /f`**

<aside>
üëæ ***Task Scheduling:***

The EXE executed, could be dropped by the malware, which then adds this as a persistence mechanism.

We can detect the creation of task by monitoring execution of the schtasks command, by checking Autostart as seen in the figure below, or by checking the **`C:\Windows\System32\Tasks directory`** for any tasks that exist there. Be aware that WMI and PowerShell also have the ability to schedule tasks.

</aside>

### Windows Startup Folders

<aside>
üëæ ***Windows Startup Folders***

User-level & System-level folders If a program was placed into a user folder, then it will only work when that user logs in, but if using a system folder, then it will be executed for any user that logs on.

One of the easiest ways to find the folder and what‚Äôs in it, is by using the Windows Run dialog box (Winkey+R) and then type ‚Äú**`*shell:startup*`**‚Äù.

The locations for all users is: ‚Äú**`C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp`**‚Äù
While for a specific user, it is: ‚Äú**`C:\Users\<Username>\AppData\Roaming\Microsoft\Windows\StartMenu\Programs\Startup`**‚Äù

</aside>

## Winlogon

The Winlogon process by default will launch the userinit.exe that is responsible for running different logon scripts and network related tasks.

## AppInit DLLs

Now since many processes might use the User32.DLL library, it means the libraries which are specified in this registry value could be used to achieve persistence. There are two registry locations:
**`‚Ä¢ HKLM\Software\Microsoft\Windows NT\CurrentVersion\Windows`**
**`‚Ä¢ HKLM\Software\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows`**

## DLL Search Order Hijacking

whenever a process wants to load a library, Microsoft Windows has a specific order to search for that library‚Äôs location. This search order is hijacked by malware authors, to achieve different malicious objectives on the victim‚Äôs system, including persistence  it is important to note that the first check will be:

1. DLLs already loaded in memory.
2. DLLs that are defined in the KnownDLLs, which could be found in the Windows Registry Key **`HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs`**

<aside>
üëæ ***What is the DLL Search Order used by Windows?***
1st: the directory from where the application was loaded.
2nd: the system directory ‚ÄúC:\Windows\System32‚Äù.
3rd: the 16-bit system directory ‚ÄúC:\Windows\System‚Äù.
4th: the Windows directory ‚ÄúC:\Windows‚Äù.
5th: the current working directory.
6th: the directories defined by the PATH environment variable.

</aside>

## Running as a Services

> Malware authors could also configure and install their malware to run in the system‚Äôs background as a service and achieve persistence by running the malware as a standalone executable, as a DLL loaded into a container (svchost.exe), or as a kernel driver service. Malware authors could use svchost.exe container to run their malware as a service, especially DLL malware. Before we go into further details, Schedule service settings under: **`HKLM\SYSTEM\CurrentControlSet\Services\Schedule`**
> 

# Tools & Automation

<aside>
üõ†Ô∏è **Tools:**

1. **Fiddler**: ‚ÄúIs a web debugging proxy tool to log all HTTP(S) traffic between your computer and the Internet. Inspect traffic, set breakpoints, and fiddle with request/response.‚Äù
2. **DependencyWalker**: Very useful tool to scan Windows executables and build a hierarchy of the libraries and functions that are being referenced by the executable.
3. **RegShot** Is an open-source tool that provides the capability of comparing between two registry snapshots.
</aside>